Exp- Breadth First Search

# BFS algorithm in Python
import collections

# BFS algorithm
def bfs(graph, root):
    visited, queue = set(), collections.deque([root])
    visited.add(root)
    while queue:
        # Dequeue a vertex from queue
        vertex = queue.popleft()
        print(str(vertex) + " ", end="")
        # If not visited, mark it as visited, and
        # enqueue it
        for neighbour in graph[vertex]:
            if neighbour not in visited:
                visited.add(neighbour)
                queue.append(neighbour)


if __name__ == '__main__':
    graph = {0: [1, 2], 1: [2], 2: [3], 3: [1, 2]}
    print("Following is Breadth First Traversal: ")
    bfs(graph, 0)



EXP- IDDFS


class Node:
    def __init__(self, state, parent, depth):
        self.state = state  # The current state of the problem
        self.parent = parent  # The parent node in the search tree
        self.depth = depth  # The depth of this node in the search tree

def iddfs(root, target, max_depth):
    for depth_limit in range(max_depth + 1):
        result = dls(root, target, depth_limit)
        if result is not None:
            return result

    return None

def dls(node, target, depth_limit):
    if node.depth > depth_limit:
        return None

    if node.state == target:
        return node

    for child_state in get_successors(node.state):
        child = Node(child_state, node, node.depth + 1)
        result = dls(child, target, depth_limit)
        if result is not None:
            return result

    return None

def get_successors(state):
    # Replace this with a function that generates successor states for your problem
    # In this example, I'm assuming a simple problem where successors are generated by incrementing the current state
    return [state + 1]

if __name__ == "__main__":
    initial_state = 0  # Replace with your initial state
    target_state = 5  # Replace with your target state
    max_depth = 10  # Maximum depth to search

    root = Node(initial_state, None, 0)
    result = iddfs(root, target_state, max_depth)

    if result is not None:
        path = []
        while result is not None:
            path.append(result.state)
            result = result.parent
        path.reverse()
        print("Path found:", path)
    else:
        print("No path found within the depth limit.")



Exp - A*


# Define the grid
grid = [
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0],
]

# Define the start and goal nodes
start = (0, 0)
goal = (len(grid) - 1, len(grid[0]) - 1)

# Define the heuristic function
def heuristic(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

# Define the successor function
def successors(node):
    # Get the row and column of the node
    row, col = node
    # Initialize an empty list of successors
    succ = []
    # Check the four adjacent cells
    if row > 0 and grid[row - 1][col] != 1:
        succ.append((row - 1, col)) # Up
    if row < len(grid) - 1 and grid[row + 1][col] != 1:
        succ.append((row + 1, col)) # Down
    if col > 0 and grid[row][col - 1] != 1:
        succ.append((row, col - 1)) # Left
    if col < len(grid[0]) - 1 and grid[row][col + 1] != 1:
        succ.append((row, col + 1)) # Right
    # Return the list of successors
    return succ

# Import the heapq module
import heapq

# Initialize the open list as a priority queue
open_list = []
# Initialize the closed list as a dictionary
closed_list = {}
# Push the start node to the open list with f = 0
heapq.heappush(open_list, (0, start))
# Set the parent of the start node to None
closed_list[start] = None

# Loop until the open list is empty
while open_list:
    # Pop the node with the lowest f from the open list
    f, node = heapq.heappop(open_list)
    # Check if the node is the goal node
    if node == goal:
        # Found the solution
        break
    # Generate the successors of the node
    for succ in successors(node):
        # Calculate the g value of the successor
        g = f + 1
        # Calculate the f value of the successor
        f = g + heuristic(succ, goal)
        # Check if the successor is already in the closed list
        if succ in closed_list:
            # Skip the successor
            continue
        # Push the successor to the open list with f
        heapq.heappush(open_list, (f, succ))
        # Set the parent of the successor to the node
        closed_list[succ] = node

# Check if the goal node was reached
if node == goal:
    # Initialize an empty list for the path
    path = []
    # Trace back the path from the goal node to the start node
    while node != start:
        # Add the node to the path
        path.append(node)
        # Get the parent of the node
        node = closed_list[node]
    # Add the start node to the path
    path.append(start)
    # Reverse the path
    path.reverse()
    # Print the path
    print("The shortest path is:")
    print(path)
else:
    # No solution was found
    print("No path was found.")



Exp- Knowledgebase in Prolog

Open SWI-Prolog and open online version of it

Write this in the left side.

% Define the student-teacher relationship

teacher(john, calculus).
teacher(lisa, physics).
teacher(bob, history).
teacher(susan, computer_science).

student(alice, calculus).
student(james, physics).
student(sarah, history).
student(michael, computer_science).

% Define which student is taught by which teacher

teaches(john, alice, calculus).
teaches(lisa, james, physics).
teaches(bob, sarah, history).
teaches(susan, michael, computer_science).


Write this in the right side box inn the bottom


?- teaches(Teacher, Student, calculus).
% This will return the teacher (Teacher) who teaches the student (Student) calculus.

?- teaches(Teacher, alice, Subject).
% This will return the subject (Subject) that the teacher (Teacher) teaches to Alice.

?- student(Student, computer_science).
% This will return the students (Student) who study computer science.



Exp- Unification algorithm in Prolog

Open SWI-Prolog and open online version of it


Write this in the left side.


% Define family relations
father(john, jim).
father(john, ann).
father(bob, mary).
mother(jane, ann).
mother(jane, jim).
mother(susan, mary).

% Define a predicate to check if two expressions are equal
equal(X, X).

% Unify two expressions
unify(X, X) :- equal(X, X).
unify(X, Y) :- father(X, Y).
unify(X, Y) :- mother(X, Y).



Write this in the right side box in the bottom


?- unify(jane, mary).
?- unify(jane, ann).
?- unify(jane, jane).



Exp- Bayes Belief Network

from pgmpy.models import BayesianNetwork
from pgmpy.factors.discrete import TabularCPD
from pgmpy.inference import VariableElimination

# Create an empty Bayesian Network
model = BayesianNetwork()

# Define the nodes in the network
model.add_nodes_from(['Weather', 'Temperature', 'PlaySoccer'])

# Define the edges between nodes
model.add_edge('Weather', 'PlaySoccer')
model.add_edge('Temperature', 'PlaySoccer')

# Define conditional probability distributions (CPDs) for each node
cpd_weather = TabularCPD(variable='Weather', variable_card=2, values=[[0.7], [0.3]])
cpd_temperature = TabularCPD(variable='Temperature', variable_card=2, values=[[0.8], [0.2]])
cpd_play_soccer = TabularCPD(variable='PlaySoccer', variable_card=2,
                            values=[[0.9, 0.6, 0.7, 0.1],  # P(PlaySoccer | Weather, Temperature)
                                    [0.1, 0.4, 0.3, 0.9]],
                            evidence=['Weather', 'Temperature'],
                            evidence_card=[2, 2])

# Add CPDs to the model
model.add_cpds(cpd_weather, cpd_temperature, cpd_play_soccer)

# Check if the model is valid
assert model.check_model()

# Perform inference
inference = VariableElimination(model)
probability = inference.query(variables=['PlaySoccer'], evidence={'Weather': 1, 'Temperature': 0})
print(probability)










